## v8引擎

### JIT
- 一直以来有两种执行js的方法，逐行解释和一次性编译成机器码，各有优缺点
- Just In Time，所有代码首先编译成字节码
- 将适合优化的代码扔进hot队列编译成机器码一直保存，如重复执行的函数
- 不能优化的和不适合优化的会打回普通队列，比如arguments和某些不能转成强类型的,如入参类型不确定和返回类型不确定的函数。
- 源代码 -> 抽象语法树 -> 字节码 -> JIT -> 本地代码

### 隐藏类
- js中并没有指针的概念，js的对象访问就是基于隐藏类的
- hidden class 会优化公用map，会记录内存偏移量。比如两个类似的对象，调用过第一个之后调用第二个特别快，因为第二个在查找时根据公用的map记录的内存偏移量直接查找
- 但是如果属性添加顺序不一样，创建的隐藏类就不样。所以对象最好采用相同的初始化顺序，以便系统可以复用隐藏类，帮助系统提升性能。

### gc
#### JavaScript所能使用的内存 64位为1.4GB，32位为0.7GB
- 启动node时可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变
- ArrayBuffer 能使用堆外内存，也能突破这个限制
#### 新生代区(32MB,32位减半，下同)
- 大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁
- 有一个指向内存区的指针，不断根据新对象的大小进行递增,到达新生代内存区的末尾，就会有一次清理
- 新生代gc是Scavenge
  -  有两块块内存FROM区和TO区，FROM找到有用的复制到TO，复制完成后会进行紧缩。然后第一块内存会被释放。最后两者互换角色
  - 从根节点出发，找到可触达的对象，如果是老生代就不管，如果是FROM区就复制到TO区
  - 复制的过程采用的是BFS（广度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象

#### 老生代区(1400MB)：
- 生存周期长,占用内存多的对象。老生代gc频率低
- 新生代扫了两次次还在引用的就扔入老生代
- To空间已经被使用了超过25%，也扔入老生代
- V8使用标记指针法，在每个字末位预留一位标记位，来区分是指针还是数据
- 老生代使用 标记清除和标记整理
  - 标记清除：标记活着的对象，清除死对象，会导致内存碎片
  - 标记整理：标记活着的对象紧缩到一起，把边界外的死对象清楚，紧缩消耗比较大
  - V8 增量标记：gc会导致js死掉，所以部分执行，切片标记
  - 标记的方法为三色gc
    - 白色代表这个对象可以被回收；
    - 黑色代表这个对象不能回收，而且它产生的所有引用都已经扫描完毕；
    - 灰色代表这个对象不能被回收，但它产生的引用还没有被扫描完。
    - 一开始默认都是白色,将根对象直接引用的标记会灰色
    - 从这些对象开始深度优先遍历，每访问到一个对象pop出来，标记为黑色。
    - 然后将它引用的对象由白色标为灰色，push到遍历栈上继续遍历
    - 如此循环最后标记的只有黑色和白色
    - 注意如果灰色的对象太大不会被扔到遍历栈上，先标记为灰色溢出，然后先遍历其他的执行gc，释放过后再回头对这些灰色重新gc
  
#### 大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象

#### 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区

#### Cell区、属性Cell区、Map区：不知道

#### gc 的时候js运行会暂停，不会出现一边清理一边产生新的垃圾，所以gc的过程时间很重要
