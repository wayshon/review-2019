## 算法

#### DFS 深度优先
- 类似二叉树的先序遍历，先查根节点，再查第一个子节点，再查子节点的子节点。没有子节点了再查兄弟节点和子节点，都没有了就继续父节点的兄弟节点
- 注意：深度DFS属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。
- 见 [DFS.BFS.js](../js/DFS.BFS.js)

#### BFS 广度优先
- 由根节点开始，遍历根节点第一层所有的子节点，即遍历到一个节点后查到这个节点的兄弟节点，而不是遍历它的子节点
- 注意：BFS从一个节点开始，尝试访问尽可能靠近它的目标节点。是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层
- 见 [DFS.BFS.js](../js/DFS.BFS.js)

#### 二叉树找路径
- 见 [treeFindRoute.js](../js/treeFindRoute.js)

#### 背包问题 动态规划
- 动态规划: 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到
  - 与其相反的是递归: 把整个拆成无数个小的，逐个解决小的整体酒解决了
- 物品一个一个的进入背包，计算从 1 开始递增到目标 weight 每个重量下的价值，即每个物品有一个数组保存了 weight 个情况下的价值
- 第一个物品进入时，从 1 开始到目标 weight，能塞入则这个重量下价值为此物品的价值，不能塞入就是0
- 从第二个物品开始，不能塞入就代表价值不变，即取上一个物品对应重量下的价值。能塞入就计算此物品价值加上 `装入后剩余空间对应的价值，即上一个物品的价值数组中对应此剩余重量的价值`，比较这个和与没塞当前物品价值(即上个物品这个重量的价值)，即可得出最大价值
- 其实就是个二位表，记录了每个物品在逐个重量情况下的最大价值
- 最终最后一个物品的价值数组的最后一个weight的值就是背包的最大价值
- 见 [pack.js](../js/pack.js)
- 参考 [背包问题 司徒正美](https://juejin.im/post/5c623ff3f265da2de1657f97)

#### 贪心算法
- 贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响

#### 求最大子数组
- 见 [findMaxChildArray.js](../js/findMaxChildArray.js)